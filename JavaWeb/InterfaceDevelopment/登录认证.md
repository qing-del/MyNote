# 登录认证

## 目录
- [登录功能实现](#登录功能实现)
    - [请求信息](#请求信息)
    - [实体类封装](#实体类封装)
    - [逻辑实现](#逻辑实现)
- [登录校验](#登录校验)
    - [存在问题与分析](#存在问题与分析)
    - [会话技术](#会话技术)
        - [传统方案](#传统方案)
            - [Cookie](#cookie)
            - [Session](#session)
        - [主流方案](#主流方案)
            - [令牌](#令牌)
    - [统一拦截](#统一拦截)

---

## 登录功能实现

### 请求信息
* 基本信息
    - 请求路径：`/login`
    - 请求方式：`POST`
* 请求参数
    - 参数格式：`application/json`
    - 请求数据样例：
    
    <details>
    <summary>请求样例代码</summary>

    ```json
    {
        "username": "admin",
        "password": "123456"
    }
    ```

    </details>

    * 参数说明：

| 名称 | 类型 | 是否必填 | 备注 |
| :---: | :---: | :---: | :---: |
| username | String | 必须 | 用户名 |
| password | String | 必须 | 密码 |

* 响应数据：
    * 参数格式：`application/json`
    * 响应数据样例：

    <details>
    <summary>响应样例代码</summary>
    
    ```json
    {
        "code": 1,
        "msg": "success",
        "data": {
            "id": 1,
            "username": "admin",
            "name": "管理员",
            "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImlhdCI6MTYxNjMxMjQxNywiZXhwIjoxNjE2MzE1MTE3fQ.ZYx5yjZ5yjZ5yjZ5yjZ"
        }
    }
    ```

    </details>

    * 参数说明：

| 名称 | 类型 | 是否必填 | 备注 |
| :--- | :--- | :--- | :--- |
| code | number | 必须 | 响应码，1：成功，0：失败 |
| msg | string | 非必须 | 提示消息 |
| data | object | 必须 | 返回的数据 |
| \|- id | number | 必须 | 用户id |
| \|- username | string | 必须 | 用户名 |
| \|- name | string | 必须 | 姓名 |
| \|- token | string | 必须 | 令牌 |

---

### 实体类封装
* 分析：要是在 Emp 类中再加入一个属性，会显得 Emp 类过于臃肿，所以我们新建一个 LoginInfo 类来用于封装登录所使用的数据
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class LoginInfo {
    private Integer id;
    private String username;
    private String name;
    private String token;
}
```

---

### 逻辑实现
* **Controller 层**：

    <details>
    <summary> 点击查看 </summary>
    
    ```java
    @Slf4j
    @RestController
    public class LoginController {
        @Autowired
        private EmpService empService;
        
        @PostMapping("/login")
        public Result login(@RequestBody Emp emp) {
            log.info("登录：{}", emp);
            LoginInfo info = empService.login(emp);
            return info != null ? Result.success(info) : Result.error("用户名或密码错误");
        }
        
    }
    ```
    
    </details>

<br>

* **Service 层**：

    <details>
    <summary> 点击查看 </summary>

    ```java
    public interface EmpService { 
        LoginInfo login(Emp emp);
    }
    ```

    ```java
    @Service
    public class EmpServiceImpl implements EmpService { 
        @Autowired
        private EmpMapper empMapper;

        @Override
        public LoginInfo login(Emp emp) { 
            //1. 调用 mapper 接口，根据用户名和密码查询员工信息
            Emp e = empMapper.selectByUsernameAndPassword(emp);

            //2. 判断：是否存在这个员工，如果存在，组装登录成功信息
            if(e != null) {
                log.info("登录成功，员工信息：{}", e);
                return new LoginInfo(e.getId(), e.getUsername(), e.getName(), "");
            }

            //3. 不存在，返回 null
            return null;
        }
    }
    ```

    </details>

<br>

* **Mapper 接口**

    <details> 
    <summary> 点击查看 </summary>

    ```java
    @Mapper
    public interface EmpMapper {
        @Select("select id, username, name from emp where username = #{username} and password = #{password}")
        Emp selectByUsernameAndPassword(Emp emp);
    }
    ```

    </details>

---

## 登录校验

### 存在问题与分析
* **问题**：<!-- Important: 安全风险问题 -->
    - **严重安全漏洞**：如果按照上述步骤实现登录页面功能之后，但是我们设置的请求接口都与登录接口一样，都是可以直接访问的，那么即便是我们不进行登录，直接跳转进入到登录之后的界面当中，也是可以访问服务器的数据，并且对服务器的数据进行操作
    - **核心问题**：我们需要对用户的登录状态进行一个校验操作
    - **解决方案**：即为在除了在登录接口之外的接口中，需要加入登录校验的这个环节

* **思路**：
    - **登录标记**：对于成功登录的用户，在后台存储一个登录成功的标记
    - **统一拦截**：对于前端页面发过来的申请，我们取做一个统一的拦截，并对其中的信息进行校验，若是在登录标记中没找到这个标记，就直接返回一个错误信息，让他去登录

* **技术选择**：
    - **登录标记**：借助 web 开发中的**会话技术**来解决
    - **统一拦截**：过滤器 Filter（JavaWeb）、拦截器 Interceptor（Spring）

![会话技术思路图](img/VerificationStrategy.jpg)

---

### 会话技术
* **会话**：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。再一次会话中可以包含多次请求和响应。
* **会话跟踪**：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。
* **会话跟踪方案**：
    - 客户端会话跟踪技术：Cookie
    - 服务器会话跟踪技术：Session
    - 令牌技术

<br>

#### 传统方案

##### Cookie
* **基本流程**
    1. 登录成功之后 服务器会创建一个 Cookie 对象，然后保存一个登录成功的标识，然后会**自动**响应给浏览器
    2. 浏览器会**自动**将 Cookie **存储**在本地，再接下来的每一次请求当中，都会**自动**的将 Cookie **携带**到服务器端
    3. 服务器会拦截发过来的请求，检查请求中的 Cookie 的信息是否正确，若是正确，则允许访问，否则返回错误信息并提示用户进行登录
* **优点**：HTTP 协议中支持的技术
    - 在 HTTP 协议中，存在**响应头**和**请求头**
    - **响应头**：服务端给前端响应 Cookie 的时候，会自动在响应头中添加`Set-Cookie:name=value`来告诉浏览器要设置 Cookie 的信息了
    - **请求头**：前端给服务端发送请求的时候，会自动在请求头中添加 Cookie 的信息，`Cookie`中会携带信息
* **缺点**：
    - 移动端 APP 无法使用 Cookie
    - 不安全，用户可以禁用自己的 Cookie
    - Cookie 不能跨域

![Cookie 跨域示意图](img/CookieCrossDomain.jpg)

* **Cookie 跟踪示例代码**

    <details>
    <summary> 点击查看 </summary>
    
    ```java
    @Slf4j
    @RestController
    public class SessionController { 
        // 设置 Cookie
        @GetMapping("/c1")
        public Result cookie1(HttpServletResponse response) {
            // 第一个值：name  第二个值：value
            response.addCookie(new Cookie("username", "zhangsan"));
            return Result.success();
        }

        // 获取 Cookie
        @GetMapping("/c2")
        public Result cookie2(HttpServletRequest request) {
            // 请求头中携带的 Cookie 会有多个 所以用数组接收
            Cookie[] cookies = request.getCookies();
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals("username")) {
                    System.out.println("username: " + cookie.getValue());
                }
            }
            return Result.success();
        }
    }
    ```
    
    </details>

<br>

##### Session
* **前置知识**：Session 的底层也是基于 Cookie 来实现的
* **基本流程**
    1. 登录成功之后，服务器会创建一个 Session 对象，将用户的信息保存在 Session 对象当中，每一个 Session 对象都会有**唯一标识**`id`，
    2. 服务器会在**响应头**中将 Session 的`id`返回给浏览器`Set-Cookie:JSESSIONID=1`
    3. 浏览器就会将`JSESSIONID`保存在 Cookie 中，下次请求的时候，就会将 Cookie 放在**请求头**中`Cookie:JSESSIONID=1`，服务器会根据 Cookie 中的`JSESSIONID`找到对应的 Session 对象，去获取用户的信息
* **优点**：相对于 Cookie 的方法，它是将用户信息**保存**在**服务器**的 Session 对象中，而浏览器拿到的只能是用户的**会话ID**，而无法看到详细的数据，会**更安全**
* **缺点**
    - 在集群服务器环境下无法直接使用 Session
    - Cookie 的**所有**缺点

![Session 集群服务器问题示意图](img/SessionClusterServer.jpg)
> 第一次访问，负载均衡分配请求到 服务器 A，在服务器 A 创建 Session 对象，并返回给浏览器，但是第二次发起请求时，负载均衡分配请求到服务器 B，此时服务器 B 无法找到 Session 对象，就会要求用户再次登录。

* **Session 跟踪代码**

    <details> 
    <summary> 点击查看 </summary>

    ```java
    public class SessionController {
        // 存值
        @GetMapping("/s1")
        public Result s1(HttpSession session) { 
            log.info("HttpSession-s1: {}", session.hashCode());
            session.setAttribute("username", "zhangsan");   //往session中存储数据
            return Result.success();
        }

        // 取值
        @GetMapping("/s2")
        public Result s2(HttpSession session) { 
            log.info("HttpSession-s2: {}", session.hashCode());
            Object username = session.getAttribute("username"); //从session中获取数据
            log.info("loginUser: {}", username);
            return Result.success(username);
        }
    }
    ```

    </details>

<br>

### 主流方案

##### 令牌
* **基本流程**：
    1. 登录成功之后，服务器会创建一个令牌，并且将令牌返回给浏览器
    2. 浏览器会在后续请求中，又将令牌传回给服务器
    3. 若是令牌**有效**，那么服务器会放行访问，否则会要求用户进行登录
* **优点**
    - 支持 PC端、移动端、小程序端
    - 解决集群环境下的认证问题
    - **减轻**服务器端的压力
* **缺点**： 需要程序员自己实现
* **JWT 令牌学习**：[JWT 令牌笔记文档](../AfterEnd/令牌.md)

<details>
<summary> <b>· 示例代码</b> </summary>

```java
package com.example.utils;

import ...;

public class JwtUtils { 
    private static final String SECRET_KEY = "SVRIRULNQQ==";    // 秘钥
    private static final long EXPIRATION_TIME = 12 * 3600 * 1000;   // 12 小时

    /**
     * 生成 JWT 令牌
     * @param claims 令牌中包含的自定义信息
     * @return 生成的 JWT 令牌字符串
     */
    public static String generateToken(Map<String, Object> claims) { 
        return Jwts.builder()
            .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
            .setClaims(claims)
            .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
            .compact();
    }

    /**
     * 解析 JWT 令牌
     * @param token JWT 令牌字符串
     * @return 解析出来包含信息的 Claims 对象
     */
    public static Claims parseToken(String token) { 
        return Jwts.parser()
            .setSigningKey(SECRET_KEY)
            .parseClaimsJws(token)
            .getBody();
    }
}
```

```java
@Slf4j
@RestControllerAdvice
public class EmpServiceImpl implements EmpService {
    @Autowired
    private EmpMapper empMapper;

    @Override
    public LogInfo login(Emp emp) {
        //1. 调用 Mapper 接口，根据用户名和密码查询员工信息
        Emp emp = empMapper.selectByUsernameAndPassword(emp);

        //2. 判断：是否存在这个员工，如果存在，组装登录成功信息
        if(e != null) {
            log.info("员工登录成功，员工信息：{}", emp);

            //生成 JWT 令牌
            Map<String, Object> claims = new HashMap<>();
            claims.put("id", emp.getId());
            claims.put("username", emp.getUsername());
            String jwt = JwtUtils.generateJwt(claims);
            
            return new LoginInfo(e.getId(), e.getUsername(), e.getName(), jwt);
        }

        //3. 不存在 返回 null
        return null;
    }
}
```

</details>

---

<br>

#### 统一拦截
* **需求**：用户登录成功之后，系统会自动下发 JWT 令牌，然后在后续的每次请求中，都需要在请求头 header 中携带到服务器，请求头的名称为 `token`，值为登陆时下发的 JWT 令牌。如果见到用户未登录，则直接响应 401 状态码。
* **基本逻辑**：
    1. 获取请求路径
    2. 判断请求路径是否为登录请求（如果是则放行，否则去请求头中获取`token`）
    3. 判断`token`是否有效
    4. 如果`token`有效，则放行，否则响应 401 状态码

<br>

* **Filter 过滤器学习笔记**: [过滤器学习笔记](../AfterEnd/过滤与拦截.md#过滤器filter)

<details>
<summary>· <b>查看 Filter 示例代码</b></summary>

```java
@Slf4j
@WebFilter(urlPatterns = "/*")
public class TokenFilter implements Filter { 
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws Exception { 
        // servletRequest、servletResponse 都是 HttpServletRequest
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        //1. 获取到请求路径
        String path = request.getRequestURI();

        //2. 判断是否是登录请求，如果路径中包含 /login，说明是登录操作，放行
        if (path.contains("login")) {
            log.info("登录请求，放行")
            filterChain.doFilter(request, response);
            return;
        }

        //3. 获取请求头中的 token
        String token = request.getHeader("token");

        //4. 判断 token 是否存在，如果不存在，说明用户没有登录，返回错误信息(响应 401 状态码)
        if (token == null || token.isEmpty()) { 
            log.info("令牌为空，响应 401 状态码");
            // HttpServletResponse.SC_UNAUTHORIZED = 401
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        //5. 若是令牌存在，校验令牌，如果校验失败，返回错误信息(响应 401 状态码)
        try { 
            JwtUtils.parseJWT(token);
        } catch (Exception e) { 
            log.info("令牌校验失败，响应 401 状态码");
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return
        }

        //6. 校验通过，放行
        log.info("令牌校验通过，放行");
        filterChain.doFilter(request, response);
    }
}
```

</details>

<br>

* **Interceptor 拦截器学习笔记**：[拦截器学习笔记](../AfterEnd/过滤与拦截.md#拦截器interceptor)

<details>
<summary><b>· 查看 Interceptor 示例代码</b></summary>

```java
@Slf4j
@Component
public class TokenInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //1. 获取到请求路径
        String requestURI = request.getRequestURI();

        //2. 判断是否是登录请i去，如果路径中共包含 /login，说明是登录操作，放行
        if (requestURI.contains("/login")) {
            log.info("登录操作，放行");
            return true;
        }

        //3. 获取请求头中的 token
        String token = request.getHeader("token");

        //4. 判断 token 是否为空，如果为空，说明未登录，返回 401 状态码
        if (token == null || token.length() == 0) {
            log.info("未登录，响应 401");
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return false;
        }

        //5. token 存在，校验令牌，如果检验失败 -> 响应 401 状态码
        try {
            Jwts.parseToken(token);
        } catch (Exception e) {
            log.info("令牌非法，响应 401");
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return false;
        }

        //6. 校验通过，放行
        return true;
    }
}
```

</details>