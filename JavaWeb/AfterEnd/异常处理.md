# 全局异常处理器
## 目录
- [异常处理](#异常处理)
- [精确化异常信息](#精确化异常信息)
- [注释全局异常处理器](#注释全局异常处理器)

---

### 异常处理
* **默认处理方式**：
    1. 正常的请求处理流程是 Frame -> Controller -> Service -> Dao -> Service -> Controller -> Frame
    2. 当在 Mapper 或者 Service 中出现异常的时候，会往回抛给 Controller，若是 Controller 中没处理异常，将会抛给 Frame，Frame 会返回一个默认的 json 格式的信息给前端
    3. 默认的 json 信息如下：
    ```json
    {
        "timestamp": "2021-05-07T07:05:05.000+00:00",
        "status": 500,
        "error": "Internal Server Error",
        "path": "/emps"
    }
    ```

* 使用 try catch 块处理异常
    * 在 Controller 层中使用 try catch 块包裹所有的逻辑代码
    ```java
    @GetMapping("/emps")
    public Result getInfo(@PathVariable Integer id) {
        try {
            log.info("根据id查询员工信息，id：{}", id);
            Emp emp = empService.getInfo(id);
            return Result.success(emp);
        } catch (Exception e) {
            return Result.error("对不起，服务器异常，请联系管理员");
        }
    }
    ```
> 这需要在每个请求中加入 try catch 块 这样会造成**代码臃肿**

* 使用全局异常处理
    * 创建全局异常处理类
    ```java
    @Slf4j
    @RestControllerAdvice
    public class GlobalExceptionHandler { 
        @ExceptionHandler
        public Result handleException(Exception e) { 
            log.error("全局异常处理器，拦截到异常", e);
            return Result.error("对不起，服务器异常，请联系管理员");
        }
    }
    ```
> 全局异常处理器 放在 com.example.exception 包下


### 精确化异常信息
1. 可以通过**观察**控制的日志信息来**确定异常类型**
2. 在全局异常处理器中 新增**捕获**特定类型异常的方法
3. 在方法中返回**Result**对象，并设置**错误信息**

- 例如：修改员工信息的时候，出现 **数据重复** 导致的异常（DuplicateKeyException）
```java
public Result handleDuplicateKeyException(DuplicateKeyException e) { 
    log.error("程序出错了，错误信息：{}", e.getMessage());
    int i = message.indexOf("Duplicate entry");
    String msg = message.substring(i);
    String[] arr = errMsg.split(" ");
    return Result.fail(arr[2] + "已存在");
}
```

### 注释全局异常处理器
* **@RestControllerAdvice** = **@ControllerAdvice** + **@ResponseBody**
* **@ExceptionHandler**