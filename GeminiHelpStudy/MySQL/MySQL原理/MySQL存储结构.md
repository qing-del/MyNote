---
title: MySQL存储结构
tags:
 - MySQL
 - 存储结构
 - Learning
create_time: 2026-02-23
---

# 目录

---

## 磁盘

### 表概念
- 可以通过此SQL语句建表
```sql
create table t(id int(11)) Engine = INNODB;
```
> [!warning] 不同的存储引擎表结构不同

![[MySQL存储结构1.png]]
> [!info] 介绍
> 只有在 5.7 以后的版本才有**独立表空间**
> 在此之前，所有表的数据和索引都会存储在 **“系统表空间”** 中
> 其另外一个称号是 **共享表空间**，即为所有表**共享**一个物理表空间文件

- 控制是否为每个表独立创建 `ibd` 文件
```sql
-- 开启 [每个表都创建表空间文件]
set @@global.innodb_file_per_table = ON;

-- 查看 [每个表都创建表空间文件] 状态
show variables like 'innodb_file_per_table';
```

![[MySQL存储结构2.png]]
> [!tip] 官方文档
> **独立表空间**相比**共享表空间**具有 _可压缩_、_可传输_ 等优势

> [!warning] 同时在 8.0 之后就没有`.frm`文件

---

### 页结构
- 这是**内存**与**磁盘**交互的**最小单位**
- 在磁盘中，每个”页“内部的地址都是都是**连续的**

> [!tip] 设计理念
> 由于多数查询的时候，大概率都是连续查询
> 所以很多时候大概率后续查询会在内存里面

- 大小**固定**为16KB，即使是**没有数据**也是这个大小
- 在**不同场景**会有不同的页结构 -- 一共有12种
- 但是都会包含有
	- 页头 - File Header
	- 页尾 - File Trailer

> 最常用的是用来存储数据和索引的”**索引页**“

#### 数据行
- 页的页头和页尾之间，主体信息会用**数据行**来填充
> [!info] 行的官方文档
> ”行“一共有四种类型，以应对不同的场景
> 在 5.7 版本之后，默认为`DYNAMIC`类型
- 查询表中行类型的方法
```sql
-- 查看某表的行类型
select t.SPACE, t.NAME, t.ROW_FORMAT
FROM information_schema.INNODB_SYS_TABLESPACES t
-- `name` : 库名/表名
WHERE name = 'fullstars/test';
```
- 行的大小为 `<= 8KB`
- 内部主要包括表里面某一行的**真实数据**和一些**额外信息**

![[MySQL存储结构3.png]]

---

### 区结构

#### 前置原因
- 当读取量上升的时候，就会出现读取一页是不够的情况
- 同时就会出现，多份数据在磁盘中很有可能**不在同一磁道**
- 这个时候就会出现**磁头移动**
> [!failure] 磁头移动是非常影响性能的

![[MySQL存储结构4.png]]

#### 区
- 每个区的大小**固定**为 1 MB
- 存放 64 个地址**连续**的页
> 这样跨页读取相关数据，大概率都在同一个区，防止出现磁头移动
> 同时，如果频繁读取某个区内的页，就会把整个区读取到内存中

> [!info] 新建表情况
> 由于新建表的时候，并不知道表的数据量级有多大
> 所以第一次并不会创建完整的区，而是只创建 6 个页
> > 在 8.0 版本之后，初次会创建 7 个页


- 而这些**零散页**会被放在**碎片区**
- 解析 6 个页的结果如下：
![[MySQL存储结构5.png]]

> 后 2个页 为**空闲页**，即为**可用页**
> 前 4个页 分别记录了**表空间和区组条目信息**、**Change buffer相关信息**、**段信息**、**索引根信息**
> 可以使用 查看行类型 的SQL语句查询，然后查看`PAGE_SIZE`和`FILE_SIZE`

- ***区的创建***
	- 当我们构建了 32个 零散页之后
	- 后续每次都会申请完整的区

> [!info] 理解
> 创建完 32个 零散页之后，会把碎片区占满
> 后续创建会直接分配一个完整的区，直到第二个区的页被用完才会创建第三个区
> 这里要注意，一开始的 32个零散页 并不会被改到区
> 开始用区之后，不会再创建零散页，会**一直**使用区


---

### 区组结构
- 当区越来越多的时候，为了便于管理区，就衍生了区组结构
- 大小固定为 `256`MB，直接由`256`个区组成
- **第一个区（特殊）**
	- 首个区的前四页比较特殊，就是刚刚说的6个初始页中的前4个
		- **表空间和区组条目信息（File Space Header）**
		- **Change buffer相关信息（Insert Buffer Bitmap）**
		- **段信息（File Segment inode）**
		- **索引根信息（B-tree Node）**

- **其他区组**
	- 首个区的前两个页均一致，分别为
		- **区组条目信息**
		- **Change buffer 信息**

> `InnoDB`通过区组可以在物理结构层面，非常高效的管理和定位到每一个”区“

![[MySQL存储结构6.png]]

---

### 段结构
- ”段“与”区“和”区组“不同，是一个**逻辑概念**，并不是空间中的连续物理区域
- 可以看作是”区“、”页“的**附加标注信息**
- **主要作用**
	- 用来**区分**不同功能的”区“和在碎片区中的”页“
	- 分有“叶子节点段”、“非叶子节点段”等
	> 跟 B+树 索引中的叶子、非叶子节点相对应
	- 由这两个段，最终构成了表空间`ibd`文件

![[MySQL存储结构7.png]]

---

### 关系总结图
![[MySQL存储结构8.png]]