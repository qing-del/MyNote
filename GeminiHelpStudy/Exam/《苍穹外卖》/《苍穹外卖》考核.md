## 实战考验
### Part 1 - 前端及格线与联调基础
- **情景题 1：接口结构变更的应对** 原本你的后端有一个查询菜品详情的接口，返回的 JSON 数据结构是这样的单体对象：

```JSON
{
  "code": 1,
  "data": { "id": 101, "name": "辣椒炒肉", "price": 25.0 }
}
```

由于业务变动，你在后端将接口改成了返回一个列表（哪怕只有一个菜）：

```JSON
{
  "code": 1,
  "data": [
    { "id": 101, "name": "辣椒炒肉", "price": 25.0 }
  ]
}
```

**问题：** 面对这个后端的改动，在 Vue 3 前端代码中，你大致需要去修改哪些地方才能让页面不报错并且正常显示菜品名称？（不需要写具体代码，描述你的排查和修改逻辑即可）

> [!info] 我的回答
> 这个变动发生之后，还是按照原来那种方式读取的话，应该是读取不出数据了，应该是要写成类似数组那样，比如原来是`res.data.id`来获取`id`，改了之后应该是要`res.data[index].id`来获取`id`这个键值了；

**情景题 2：登录过期与跨域问题** 你在本地启动了前后端项目准备测试。
1. 点击前端页面上的某个按钮，控制台报了 `401 Unauthorized`。请问这大概率是哪里的问题？前端应该怎么处理这个情况？
2. 如果浏览器控制台报了红色的 `CORS error`（跨域错误），你知道这是为什么吗？作为后端，你会怎么解决它？

> [!info] 我的回答
> 1.①面对第一种情况的话，这个时候就是token过期了，至于怎么触发，按照我目前的水平，我感觉应该是同一个登录会话时间很久了，超过了token的有效期导致401 ②如果是前端做做了某件事情会导致这个问题，那么这个时候大概率是前端某个地方有个代码逻辑使其触发了`localStore.clear()`这个函数吧（应该是这样写，反正大概逻辑是这样），小概率是后端全局异常处理器有问题，不是auth相关的报错，丢了个401回来导致触发清除逻辑了。
> 2. 第二个小问比较简单，就是`Controller`里面没有放行跨域请求，请求直接被拒绝了；


### Part 1.5 前端联调进阶：数据绑定与网络排查（直击你的薄弱点）
- 你说过，如果涉及多文件数据传输和复杂转换，你会有点懵。作为后端，你不需要手写这些复杂组件，但你必须具备**“自证清白”**和**“精准甩锅”**的能力。

**情景题 3：复杂的“新增套餐”联调** 在苍穹外卖中，“新增套餐”非常复杂。前端有一个父组件（填套餐名字、价格），里面嵌套了一个子组件（弹窗选择多个菜品）。前端开发把这些数据拼装好发给你。 你的后端 Controller 长这样：
```Java
@PostMapping("/withDish")
public Result save(@RequestBody SetmealDTO setmealDTO) { ... }
```
`SetmealDTO` 里面包含了一个 `List<SetmealDish> setmealDishes`。 **现在出bug了：** 前端点了保存，你的后端报了 `400 Bad Request`（或者后端接收到了请求，但是 `setmealDishes` 这个 List 是 `null`）。前端小哥跑来找你，信誓旦旦地说：“我子组件的数据肯定传给父组件了，我全发给你了，是你后端的问题！”

**你的考题：** 作为后端，在你完全看不懂他 Vue3 组件传值代码的情况下，你要通过什么工具、看哪个具体的部位，来**拿出铁证**告诉他：“你看，你发给我的数据结构根本不对/缺失了”？你需要他把数据调整成什么格式，你的 `@RequestBody` 才能正确解析这个 List？

> [!info] 我的回答
> 说真的，我一开始看到400的时候我也不知道什么，因为我还没学状态码，我只知道401、403、404、500这四个，其他我都是查AI的，但是你的提示bad request，所以我感觉应该是前端请求出了问题，或者是传递的参数有问题，就是名字对上了，但是内容牛头不对马嘴（比如变量名对不上，或者是变量名对上了但传递的格式对不上），或者是格式解析错误，至于证据的话，直接点开它的前端控制台按f12，看一下网络里面的发起请求的内容，然后拿去和后端接收的实体类做个比较，再拿出开发文档来进行比对，就可以知道是谁错了；



**情景题 4：ThreadLocal 的致命隐患** 苍穹外卖中，你使用 `ThreadLocal` 配合拦截器，保存了当前登录的员工 ID。由于 Tomcat 底层使用的是**线程池（Thread Pool）**，处理完一个 HTTP 请求后，线程不会被销毁，而是被放回池中供下一个请求复用。 
**你的考题：** 如果你的拦截器（Interceptor）在 `preHandle` 里面往 `ThreadLocal` 存了用户 ID，但是你**忘记了**在 `afterCompletion` 里面调用 `ThreadLocal.remove()`。请推演一下，在系统并发运行一段时间后，会发生怎样可怕的**业务级 Bug**？（提示：想象一下用户 A 和用户 B 先后访问系统）。

> [!info] 我的回答
> 这样会导致所谓的`内容泄露`，但是我还不知道什么叫内存泄漏，我也并没系统学习并发编程，但是按照我在学习JavaSE的时候了解过一点什么是多线程和线程池的模型和工作原理，我感觉这会导致没有清除内存数据就放回去内存池，因为线程池里的线程是会循环利用的，而`Localthread`又是存储一个线程局部变量的地方，那么肯定会引起线程安全问题，会导致下一个人取出来是得到的是之前的人的数据，进而导致之前的账号数据被污染或者说是损坏，应该是这样；


**情景题 5：事务失效的经典陷阱** 在处理订单或者复杂的级联保存时，我们会用到 `@Transactional` 来保证事务一致性。 假设你的 `OrderService` 中有如下代码（伪代码）：
```Java
public class OrderServiceImpl implements OrderService {

    // 这是一个没有事务的普通方法
    public void createOrderProcess(OrderDTO dto) {
        // 做一些前置校验...
        // 然后调用本类中带有事务的方法去落库
        this.saveOrderAndDeductStock(dto); 
    }

    @Transactional
    public void saveOrderAndDeductStock(OrderDTO dto) {
        orderMapper.insert(dto); // 插入订单
        int i = 1 / 0;           // 模拟抛出异常（比如算术异常）
        stockMapper.deduct();    // 扣减库存
    }
}
```

**你的考题：** 如果前端调用了 `createOrderProcess` 方法，在执行到 `1 / 0` 时必然会抛出异常。请问：`orderMapper.insert(dto)` 插入的这条订单记录，**会不会被回滚？为什么？**（提示：Spring 事务的底层是基于 AOP 动态代理实现的）。

> [!info] 我的回答（第一次回答）
> 肯定会回滚，我大致了解基本原理，就是MySQL中开启事务之后，使用的增删改操作都会暂时保存到缓存里面，但是还没有真正提交到数据库，那么如果这个时候程序出现了异常，那实际上就是对还在缓存中没提交的数据进行回滚（即为不提交到数据库）。再结合你的提示和我对AOP的了解，那么我猜测应该就是AOP用的是`@Around`注解，里面应该是写有一个`if (not exist exception) jdbc.submit(change)`，或者是存在异常则执行回滚语句，具体我还不知道，但是我好像有印象（应该是有回滚和提交两条SQL语句的）；


> [!failure] 错误后的理解：
> 我靠，其实我知道service里面相互调用会导致AOP失效这个现象，但是一时间没反应过来，但是我原本并不知道原理，可能是我JavaSE动态代理那里学得还不够扎实，但是你说了之后好像我回忆起来，似乎是别的地方调用代理对象才会出发动态代理，我打个比方，就是商家请明星唱歌，明星有个代理就是它的经纪人，商家找明星唱歌和跳舞，肯定要先找经纪人（代理），就会执行经纪人的代理逻辑（AOP代码），如果是明星自己要求自己唱完歌就跳舞，那么这个跳舞就是明星自己发起的，就不会经过代理，我这个理解没问题吧；


#### 拔高题 1：MySQL 优化的“反噬” (The Database Bottleneck)
你提到你做了一个很棒的优化：把循环里的查询 `for(...) { select by id }` 改成了 `SELECT * FROM table WHERE id IN (1, 2, 3...)`。 **情景：** 现在你的项目火了，这个 `IN` 里面的 ID 数量不是 10 个，而是变成了 **5 万个**。 **问题：**
1. 如果你直接把 5 万个 ID 塞进 `WHERE id IN (...)` 发给 MySQL，从网络传输和 MySQL 底层执行的角度来看，会发生什么可怕的事情？（提示：可以联想一下 MySQL 收到的 SQL 语句会有多长）。
2. 在不改动表结构的前提下，你会如何在 Java 后端代码中优雅地处理这 5 万个 ID 的查询？

> [!info] 我的回答
> 我是真不会，我完全不知道咋搞，所以我打算自己用自己的计算机理解猜一下。按照我目前理解的架构模型，窗口接待并处理逻辑的人员（Java）不能一下子把要求命令塞给运输车（IO网络运输层，在Java和MySQL之间应该是不会放入Redis的，这里我只知道还有MQ，但是我没学过，但是这里不引入MQ，因为我不会，甚至都不知道有啥作用，只知道大概好像可以干什么），因为运输车可能装不下，所以窗口接待人员（Java）将所有请求按照某个上限量规定来拆分这个大请求来进行多次运输，虽然慢一点，但是不会引起仓库管理人员（MySQL）崩溃，因为仓库管理人员的运算能力（CPU）是不如接待人员（Java）的，所以可以分次取并交给Java来算。如果我会MQ的话，感觉这里应该是可以用MQ？（不太清楚）。反正总的意思就是Java把这么大的量分成多次batch请求，但是又不是N+1那种，我感觉应该是这样处理；


#### 拔高题 2：超卖问题 (The Concurrency Nightmare)
苍穹外卖是一个“单体应用”（意味着你的 Java 代码只在一台电脑上运行）。 **情景：** 老板让你加一个“1分钱秒杀限量 10 份红烧肉”的功能。你的代码逻辑是：
```Java
// 1. 查询当前剩余库存
int stock = dishMapper.getStock(dishId);
if (stock > 0) {
    // 2. 扣减库存
    dishMapper.updateStock(dishId, stock - 1);
    // 3. 生成订单
    createOrder();
}
```
你很聪明，知道这有并发问题，所以你给这个方法加了 Java 的 `synchronized` 锁，确保同一时刻只有一个线程能执行这段代码。在本地测试完美，哪怕 100 个人同时点，也只卖出 10 份。 **现在的变数：** 项目上线时，为了扛住千万级流量，运维把你的这个 Java 服务复制了 3 份，分别部署在了 3 台不同的服务器上（Server A, Server B, Server C），前面用 Nginx 做负载均衡。 **问题：** 请运用你的逻辑思维推演一下：在 3 台服务器同时运行的情况下，如果 1000 个人在同一毫秒发起抢购，你的 `synchronized` 锁还能防得住超卖吗？最多可能会卖出多少份红烧肉？为什么？

> [!info] 我的回答
> 我认为防不住，最多会卖出30份（极端的情况），因为这个同步锁只在一个服务器之中起作用，但是无法阻止另外两个服务器也在处理这个事务，所以这个方法是锁不住的，按照我目前还没学JUC但在JavaSE中了解过同步锁，那么它应该可以通过锁变量，就是在这个`10`上面做功夫，比如加入一个只有一个服务器处理这个`10`变量的带有锁方法的Service，就是不能多服务器来处理对这个变量的增删改查，同时要在这一个服务器里面加入特判，判断是否归零，归零可以直接设置缓存（缓存就是直接告诉后面的请求，老子卖完了，没有了，后面的都回家吧），目前我只能想到解决办法；

---

## 期末考试打分
- 出题人：Gemini 3.1 Pro
- Gemini 打分：88/100